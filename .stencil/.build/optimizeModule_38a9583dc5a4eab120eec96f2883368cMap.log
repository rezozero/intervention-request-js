{"version":3,"names":["interventionRequestPictureCss","InterventionRequestPicture","sourceHandler","window","interventionRequestJS","debug","console","log","this","observer","resetMedia","initObserver","componentWillLoad","strategyInstance","strategies","strategy","isWebp","src","nativeLoading","HTMLImageElement","prototype","forceIo","error","componentDidLoad","loading","loadMedia","IntersectionObserver","entries","onIntersect","observe","el","forEach","entry","isIntersecting","disconnect","elements","querySelectorAll","element","dataset","setAttribute","srcset","removeAttribute","onReady","loaded","loadingCompleted","emit","onError","buildPicture","mediaElements","fallbackSources","cropFitOperation","crop","fit","width","height","media","length","map","format","formatIndex","sources","filter","source","sourceIndex","formatPath","baseUrl","webp","push","h","type","rule","join","replace","RegExp","mimeType","cropFitOperationArray","split","parseInt","sizes","alt","onLoad","operations","innerWidth","Math","floor","Object","assign","mediaOptions","render","Host","class"],"sources":["src/components/intervention-request-picture/intervention-request-picture.css?tag=intervention-request-picture","src/components/intervention-request-picture/intervention-request-picture.tsx"],"sourcesContent":[":host {\n    --ir-object-fit: fill;\n    --ir-object-position: inherit;\n    --ir-width: 100%;\n    --ir-height: auto;\n    --ir-max-width: none;\n    --ir-max-height: none;\n\n    display: block;\n}\n\nimg {\n    object-fit: var(--ir-object-fit);\n    object-position: var(--ir-object-position);\n    font-family: 'object-fit';\n    display: block;\n    width: var(--ir-width);\n    height: var(--ir-height);\n    max-width: var(--ir-max-width);\n    max-height: var(--ir-max-height);\n}\n","import { Component, Prop, Host, h, Element, State, Event, EventEmitter, Watch } from '@stencil/core'\nimport strategies from '../../strategies/index'\nimport Strategy from '../../utils/strategy'\nimport { isWebp } from '../../utils/utils'\nimport { InterventionRequestFormat, InterventionRequestMedia } from '../../intervention-request'\nimport { InterventionRequestStrategyFormat } from '../../strategies'\n\n/**\n * InterventionRequest Picture\n * @description Picture component\n * @author ravorona\n */\n@Component({\n    tag: 'intervention-request-picture',\n    styleUrl: 'intervention-request-picture.css',\n    shadow: false,\n})\nexport class InterventionRequestPicture {\n    /**\n     * Own properties\n     */\n    private strategyInstance?: Strategy\n    private isWebp: boolean\n    private nativeLoading: boolean\n    private observer: IntersectionObserver\n\n    /**\n     * Component element reference\n     */\n    @Element()\n    el: HTMLElement\n\n    /**\n     * Source\n     */\n    @Prop()\n    src!: string\n\n    /**\n     * Alt attribute\n     */\n    @Prop()\n    alt: string\n\n    /**\n     * Crop attribute\n     */\n    @Prop()\n    crop?: string\n\n    /**\n     * Fit attribute\n     */\n    @Prop()\n    fit?: string\n\n    /**\n     * Width attribute\n     */\n    @Prop()\n    width?: number\n\n    /**\n     * Height attribute\n     */\n    @Prop()\n    height?: number\n\n    /**\n     * Strategy\n     */\n    @Prop()\n    strategy: string\n\n    /**\n     * Base URL\n     */\n    @Prop()\n    baseUrl: string\n\n    /**\n     * Source list\n     */\n    @Prop()\n    media?: InterventionRequestMedia\n\n    /**\n     * Mime type\n     */\n    @Prop()\n    mimeType?: string\n\n    /**\n     * Force intersection observer\n     * for lazy load\n     */\n    @Prop()\n    forceIo?: boolean\n\n    /**\n     * Loading type\n     */\n    @Prop()\n    loading: 'lazy' | 'eager' | 'auto'\n\n    /**\n     * Media loaded\n     */\n    @State()\n    private loaded: boolean = false\n\n    /**\n     * Loading completed event emitter\n     */\n    @Event()\n    private loadingCompleted: EventEmitter<boolean>\n\n    @Watch('src')\n    sourceHandler (): void {\n        if (window.interventionRequestJS && window.interventionRequestJS.debug) {\n            console.log('src changed', this.observer)\n        }\n\n        this.resetMedia()\n        this.initObserver()\n    }\n\n    /**\n     * Component wiill load\n     * Component lifecycle method\n     * @return void\n     */\n    componentWillLoad(): void {\n        this.strategyInstance = strategies[this.strategy]\n        this.isWebp = isWebp(this.src)\n        this.nativeLoading = ('loading' in HTMLImageElement.prototype) && !this.forceIo\n\n        if (!this.strategyInstance && window.interventionRequestJS && window.interventionRequestJS.debug) {\n            console.error('strategy error', `${this.strategy} strategy is missing`)\n        }\n    }\n\n    /**\n     * Component did load\n     * Component lifecycle method\n     * @return void\n     */\n    componentDidLoad(): void {\n        if (this.nativeLoading || this.loading !== 'lazy') {\n            this.loadMedia()\n        } else {\n            this.initObserver()\n        }\n    }\n\n    /**\n     * Init intersection observer\n     */\n    private initObserver (): void {\n        this.observer = new IntersectionObserver((entries: Array<IntersectionObserverEntry>): void => this.onIntersect(entries))\n        this.observer.observe(this.el)\n    }\n\n    /**\n     * Intersection observer callback\n     * @param entries\n     */\n    private onIntersect (entries: Array<IntersectionObserverEntry>): void {\n        entries.forEach(\n            (entry: IntersectionObserverEntry): void => {\n                if (entry.isIntersecting) {\n                    this.observer.disconnect()\n                    this.loadMedia()\n                }\n            }\n        )\n    }\n\n    /**\n     * Load media\n     * Toggle attributes\n     */\n    private loadMedia (): void {\n        const elements = this.el.querySelectorAll('source, img')\n\n        elements.forEach(\n            (element: HTMLSourceElement|HTMLImageElement): void => {\n                if (element.dataset.src) {\n                    element.setAttribute('src', element.dataset.src)\n                }\n\n                if (element.dataset.srcset) {\n                    element.setAttribute('srcset', element.dataset.srcset)\n                }\n            }\n        )\n    }\n\n    /**\n     * Load media\n     * Toggle attribures\n     */\n    private resetMedia (): void {\n        const elements = this.el.querySelectorAll('source, img')\n\n        elements.forEach(\n            (element: HTMLSourceElement|HTMLImageElement): void => {\n                element.removeAttribute('src')\n                element.removeAttribute('srcset')\n            }\n        )\n    }\n\n    /**\n     * Media ready\n     */\n    public onReady (): void {\n        this.loaded = true\n\n        if (this.loadingCompleted) {\n            this.loadingCompleted.emit(true)\n        }\n    }\n\n    /**\n     * On error\n     */\n    public onError (): void {}\n\n    /**\n     * Build picture tag\n     * @return HTMLPictureElement\n     */\n    private buildPicture(): HTMLPictureElement {\n        let mediaElements: Array<any> = []\n        let fallbackSources!: string\n        let cropFitOperation = this.crop || this.fit\n        let width = this.width\n        let height = this.height\n\n        if (this.media && this.media.length) {\n            /**\n             * Loop thru formats\n             * Define all <source>\n             */\n            mediaElements = this.media.map(\n                (format: InterventionRequestFormat, formatIndex: number): Array<HTMLSourceElement|HTMLImageElement> => {\n                    let srcset: Array<string> = []\n                    let sources: Array<HTMLSourceElement|HTMLImageElement> = []\n\n                    /**\n                     * Ensure that format.srcset\n                     * contains all required properties\n                     */\n                    format.srcset = format.srcset.filter(\n                        (source: InterventionRequestStrategyFormat): boolean => {\n                            return !!(source.format)\n                        }\n                    )\n\n                    /**\n                     * Generate srcset\n                     * foreach srcset rules\n                     */\n                    if (format.srcset && format.srcset.length) {\n                        /**\n                         * Loop thru srcset\n                         * Define all srcset for responsive behavior\n                         */\n                        srcset = format.srcset.map(\n                            (source: InterventionRequestStrategyFormat, sourceIndex: number): string => {\n                                if (formatIndex === this.media.length -1 && sourceIndex === format.srcset.length - 1) {\n                                    cropFitOperation = source.format.crop || source.format.fit\n                                    fallbackSources = this.strategyInstance.formatPath(this.src, source, this.baseUrl)\n                                }\n\n                                return `${this.strategyInstance.formatPath(this.src, source, this.baseUrl, true)}`\n                            }\n                        )\n                    }\n\n                    if (srcset.length) {\n                        /**\n                         * Generate webp source\n                         * for non webp\n                         * and only if preferWebp is true\n                         */\n                        if (this.strategyInstance.webp && !this.isWebp) {\n                            sources.push(\n                                <source\n                                    type={ 'image/webp' }\n                                    media={ format.rule }\n                                    data-srcset={ srcset.join(', ').replace(new RegExp(this.src, 'g'), `${this.src}.webp`) } />\n                            )\n                        }\n\n                        /**\n                         * Generate common source\n                         * Regardless of media type\n                         */\n                        sources.push(\n                            <source\n                                type={ this.mimeType }\n                                media={ format.rule }\n                                data-srcset={ srcset.join(', ') } />\n                        )\n\n                        /**\n                         * Set width & height\n                         * according to fallback width & height fit / crop operation\n                         */\n                        if (cropFitOperation) {\n                            const cropFitOperationArray = cropFitOperation.split('x')\n\n                            width = parseInt(cropFitOperationArray[0])\n                            height = parseInt(cropFitOperationArray[1])\n                        }\n\n                        /**\n                         * Generate fallback\n                         */\n                        if (fallbackSources) {\n                            sources.push(\n                                <img\n                                    width={ width }\n                                    height={ height }\n                                    sizes={ format.rule }\n                                    alt={ this.alt || this.src }\n                                    loading={ this.loading }\n                                    data-src={ fallbackSources }\n                                    data-srcSet={ srcset.join(', ') }\n                                    onLoad={ () => this.onReady() }\n                                    onError={ () => this.onError() } />\n                            )\n                        }\n                    }\n\n                    return sources\n                }\n            )\n        } else {\n            const operations: InterventionRequestStrategyFormat = {}\n\n            width = width || window.innerWidth\n            height = height || Math.floor(window.innerWidth * 3 / 4)\n\n            /**\n             * Set width & height\n             * according to fallback width & height fit / crop operation\n             */\n            if (cropFitOperation) {\n                const cropFitOperationArray = cropFitOperation.split('x')\n\n                width = parseInt(cropFitOperationArray[0])\n                height = parseInt(cropFitOperationArray[1])\n            }\n\n            if (window.interventionRequestJS) {\n                operations.format = {\n                    ...window.interventionRequestJS.mediaOptions,\n                    width: width,\n                    height: height\n                }\n            }\n\n            fallbackSources = this.strategyInstance.formatPath(this.src, operations, this.baseUrl)\n\n            /**\n             * Original media\n             * In case no formats provided\n             */\n\n            /**\n             * Generate webp source\n             * for non webp\n             * and only if preferWebp is true\n             */\n            if (this.strategyInstance.webp && !this.isWebp) {\n                mediaElements.push(\n                    <source\n                        type={ 'image/webp' }\n                        data-srcset={ `${ fallbackSources }.webp` } />\n                )\n            }\n\n            /**\n             * Generate common source\n             * Regardless of media type\n             */\n            mediaElements.push(\n                <source\n                    type={ this.mimeType }\n                    data-srcset={ fallbackSources } />,\n                <img\n                    width={ width }\n                    height={ height }\n                    alt={ this.alt || this.src }\n                    loading={ this.loading }\n                    data-src={ fallbackSources }\n                    onLoad={ () => this.onReady() }\n                    onError={ () => this.onError() }/>\n            )\n        }\n\n        return (\n            <picture>\n                { mediaElements }\n            </picture>\n        )\n    }\n\n    /**\n     * Component render\n     * Component lifecycle method\n     * @return HTMLInterventionRequestPictureElement\n     */\n    render(): HTMLInterventionRequestPictureElement {\n        return (\n            <Host class={{ loaded: this.loaded }}>\n                { this.strategyInstance && this.buildPicture() }\n            </Host>\n        )\n    }\n}\n"],"mappings":"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"}